/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Kdump.ycp
 * Package:	Configuration of kdump
 * Summary:	Kdump settings, input and output functions
 * Authors:	Jozef Uhliarik <juhliarik@suse.com>
 *
 * $Id: Kdump.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of kdump.
 * Input and output routines.
 */

{

module "Kdump";
textdomain "kdump";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "BootCommon";
import "Storage";
import "Map";
import "Bootloader";
import "Service";
import "Popup";
import "Arch";
import "Mode";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * List of available partiotions
 * with known partition
 *
 * list <string>
 */
global list <string> available_partitions =[];


/**
 * List of available partiotions
 * without filesystem or with uknown
 *
 * list <string>
 */
global list <string> uknown_fs_partitions =[];

/**
 * Total available memory
 * 
 *
 * integer
 */
global integer total_memory =0;

/**
 * Boolean option indicates kernel parameter
 * "crashkernel"
 *
 * boolean true if kernel parameter is set
 */
global boolean crashkernel_param = false;

/**
 * String option indicates value of kernel parameter
 * "crashkernel"
 *
 * string value of kernel parameter
 */
global string crashkernel_param_value = "";

/**
 * Boolean option indicates add kernel param
 * "crashkernel"
 *
 * boolean true if kernel parameter will be add
 */
global boolean add_crashkernel_param = false;


/**
 * String option for alocate of memory for boot param
 * "crashkernel"
 *
 * string value number of alocate memory
 */
global string alocated_memory = "128";

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * map of deafult values for options in UI
 *  
 * global map <string, string >
 */

global map <string, string > DEFAULT_CONFIG = $[
     "KDUMP_KERNELVER"              : "kdump",
     "KDUMP_COMMANDLINE"            : "",
     "KDUMP_COMMANDLINE_APPEND"     : "",  
     "KEXEC_OPTIONS"                : "",  
     "KDUMP_RUNLEVEL"               : "1",
     "KDUMP_IMMEDIATE_REBOOT"       : "yes",
     "KDUMP_TRANSFER"               : "",
     "KDUMP_SAVEDIR"      	    : "file:///var/log/dump",
     "KDUMP_KEEP_OLD_DUMPS"         : "5",
     "KDUMP_FREE_DISK_SIZE"    	    : "64",
     "KDUMP_DUMPDEV"           	    : "",
     "KDUMP_VERBOSE"      	    : "3",
     "KDUMP_DUMPLEVEL"		    : "0",
     "KDUMP_DUMPFORMAT"		    : "ELF", //or "compressed"
];

/**
 * map <string, string > of kdump settings
 *    
 */
global map <string, string > KDUMP_SETTINGS = $[];

/**
 * time for progress bar
 *    
 */
integer sl = 500;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


/**
 * Read disk partitions
 *
 *  @return boolean successfull
 */

boolean ReadDiskPartitions () {
  // get complete map from Storage module
  map<string,map> tg = Storage::GetTargetMap();
  // extract only real disks from target map.
  map<string,map> disks = filter( string k, map disk, tg, ``(disk["type"]:`CT_UNKNOWN==`CT_DISK));    
  // extract only disks
  list <string> list_of_disks = (list<string>) Map::Keys(disks);
  //get a list of all partitions usable for data storage
  list <string> list_disks = (list<string>) Map::Keys(disks);

  y2milestone("[kdump] (ReadDiskPartitions)  ----------------Begin of ReadDiskPartitions ()--------------");
  y2milestone("[kdump] (ReadDiskPartitions) list of disks: %1", list_disks);

  list<map> data_parts = [];
  foreach (string key, list_disks, {
    data_parts = data_parts + filter( map p, disks[key,"partitions"]:[], ``(p["type"]:`primary!=`extended));
  });    
  //list<map> data_parts = filter( map p, disks["/dev/sda","partitions"]:[], ``(p["type"]:`primary!=`extended));

  //parse partiotions with uknown file system
  list<map> unknown = [];
  unknown = filter( map p, data_parts, ``(p["detected_fs"]:nil==`unknown));
 

  list<string> uknown_partitions = [];
  if (size(unknown)>0)
     uknown_partitions = maplist( map p, unknown, ``(p["device"]:""));
  y2milestone("[kdump] (ReadDiskPartitions) list of device names of partitions without filesystem: %1", uknown_partitions);
  uknown_fs_partitions = uknown_partitions;
  // get list of device names of partitions
  list<string> parts = maplist( map p, data_parts, ``(p["device"]:""));
 
  y2milestone("[kdump] (ReadDiskPartitions) list of device names of partitions: %1", parts);

  // get list of udev ids of partitions, need to prepend "/dev/disk/by-id/"
  list<string> udevids = maplist( map p, data_parts, ``(p["udev_id",0]:""));
 
  y2milestone("[kdump] (ReadDiskPartitions) list of udev ids of partitions: %1", udevids);

  
  //combination name + uids to one list
  integer i = 0;
  //available_partitions = parts;
  foreach (string key, udevids, {
    //string disk_from_partition = filterchars(parts[i]:"", "abcdefghijklmnopqrstuvwxyz/");
    string value = "/dev/disk/by-id/" + udevids[i]:"" +" ( " + parts[i]:"" +" )";
    available_partitions = available_partitions + value;
    i= i+1; 
  });
 
  y2milestone("[kdump] (ReadDiskPartitions) list of available partitions (name + uid): %1", available_partitions);
  y2milestone("[kdump] (ReadDiskPartitions)  ------------End of ReadDiskPartitions ()--------------------------");
  return true;
} 


/**
 * Read current kdump configuration
 *
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */

boolean ReadKdumpKernelParam () {

  string result = Bootloader::getKernelParam (Bootloader::getDefaultSection (), "crashkernel");
  //Popup::Message(result);
  if (result == "false") {
     crashkernel_param = false;
     add_crashkernel_param = false;
  } else { 
     crashkernel_param = true;
     add_crashkernel_param = true;
  }

  crashkernel_param_value = result;
  if (result != "false")
     alocated_memory = substring(result,0,search(result,"@"));

  //Popup::Message(alocated_memory);

  return true;
}

/**
 * Read available memory
 *
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */

boolean ReadAvailableMemory () {

  list <map> output =  (list<map>)SCR::Read(.probe.memory);
  y2milestone("[kdump] (ReadAvailableMemory) SCR::Read(.probe.memory): %1", output);

  map <any,any> resor = $[];
  list <any> temp = maplist(map mem, output,{    
    return mem["resource"]:nil;
  });
  //y2milestone("[kdump] (ReadAvailableMemory) temp: %1", temp);
  resor = tomap(temp[0]:nil);
  
  output = (list<map>)resor["phys_mem"]:nil;
  temp = maplist(map mem, output,{    
    return mem["range"]:nil;
  });
  //list <any> range = maplist(map resor["phys_mem"]:nil);
 
  //resor = (map)range;
  total_memory = tointeger(temp[0]:nil)/1048576;
  y2milestone("[kdump] (ReadAvailableMemory) total phys. memory [MB]: %1", tostring(total_memory));
  
  return true;
}
/**
 * Read current kdump configuration
 *
 *  @return boolean successfull
 */
boolean ReadKdumpSettings () {
    KDUMP_SETTINGS = DEFAULT_CONFIG;
    foreach (string key,  SCR::Dir(.sysconfig.kdump), {
	string val = (string) SCR::Read(add(.sysconfig.kdump, key));
        if (val != nil) KDUMP_SETTINGS[key] = val;
    });
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("kdump configuration has been read: %1", KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");

    

    return true;
}



/**
 * Write current kdump configuration
 *
 *  @return boolean successfull
 */
boolean WriteKdumpSettings () {

    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("Writing kdump configuration: %1", KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");


    foreach (string option_key, string option_val, KDUMP_SETTINGS, {
	SCR::Write(add(.sysconfig.kdump, option_key), option_val);
    });
    SCR::Write(.sysconfig.kdump, nil);
        
    return true;
}


/**
 * Write kdump boot argument crashkernel
 * set kernel-kdump start at boot
 *
 *  @return boolean successfull
 */
boolean WriteKdumpBootParameter () {
  
  boolean result = true;
  if (add_crashkernel_param) {
     string crash_value = "";
     crash_value = alocated_memory+"@";
     if ((Arch::i386()) ||(Arch::x86_64())) {
        crash_value = crash_value + "16M";
     } else if (Arch::ia64()) {
        crash_value = crash_value + "0";
     } else if (Arch::ppc64()) {
        crash_value = crash_value + "32M";
     } else {
        if (!Mode::commandline())
           Popup::Error(_("Unsupported architecture, \"crashkernel\" was not added"));
        return false;
     }
           
     if ((!crashkernel_param) || ((crash_value != crashkernel_param_value) && (add_crashkernel_param))) {

        //Popup::Message(Bootloader::getDefaultSection ());
        result = Bootloader::setKernelParam (Bootloader::getDefaultSection (), "crashkernel", crash_value); //        
        //Popup::Message(crash_value);
        if (!Mode::commandline())
           Popup::Message(_("For applying changes is necessary reboot."));

        return result;
     }

     
     //start kernel-kdump at boot
     Service::Enable("kernel-kdump");
  } else {
    if (crashkernel_param) {
       //delete crashkernel paramter from bootloader
       result = Bootloader::setKernelParam (Bootloader::getDefaultSection (), "crashkernel", "false");
       if (!Mode::commandline())
          Popup::Message(_("For applying changes is necessary reboot."));
    }
    Service::Disable("kernel-kdump");
    return result;
  }    
  return true;
}



/**
 * Read all kdump settings
 * @return true on success
 */
global boolean Read() {

    /* Kdump read dialog caption */
    string caption = _("Initializing kdump Configuration");
    integer steps = 4;
    sleep(sl);

    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/4 */
	    _("Read the config file"),
	    /* Progress stage 2/4 */
	    _("Read disk partitions"),
            /* Progress stage 3/4 */
            _("Read kernel boot options"),
            /* Progress stage 4/4 */
            _("Read available memory"),
 
	], [
	    /* Progress step 1/4 */
	    _("Reading the config file..."),
            /* Progress step 2/4*/
            _("Reading partitions of disks..."),
            /* Progress finished 3/4*/ 
            _("Reading available memory..."),
	    /* Progress finished 4/4*/
	    Message::Finished()
	],
	""
    );

    sleep(sl);
    // read database
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!ReadKdumpSettings ()) Report::Error(_("Cannot read config file /etc/sysconfig/kdump"));
    //sleep(sl);

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadDiskPartitions ()) Report::Error(_("Cannot read disk partitions."));
    //sleep(sl);

   // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadKdumpKernelParam ()) Report::Error(_("Cannot read kernel boot options"));
    //sleep(sl);

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadAvailableMemory ()) Report::Error(_("Cannot read available memory"));
    //sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all kdump settings
 * @return true on success
 */
global boolean Write() {

    /* Kdump read dialog caption */
    string caption = _("Saving kdump Configuration");

    //number of stages
    integer steps = 2;

    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Update boot options")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Updating boot options..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!WriteKdumpSettings ()) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // write/delete bootloader option for kernel "crashkernel"
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(!WriteKdumpBootParameter ()) Report::Error (_("Adding crashkernel parameter to bootloader fault."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/* EOF */
}
