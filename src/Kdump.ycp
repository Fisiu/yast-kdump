/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Kdump.ycp
 * Package:	Configuration of kdump
 * Summary:	Kdump settings, input and output functions
 * Authors:	Jozef Uhliarik <juhliarik@suse.com>
 *
 * $Id: Kdump.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of kdump.
 * Input and output routines.
 */

{

module "Kdump";
textdomain "kdump";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "BootCommon";
import "Storage";
import "Map";
import "Bootloader";
import "Service";
import "Popup";
import "Arch";
import "Mode";
import "BootCommon";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * List of available partiotions
 * with known partition
 *
 * list <string>
 */
global list <string> available_partitions =[];


/**
 * List of available partiotions
 * without filesystem or with uknown
 *
 * list <string>
 */
global list <string> uknown_fs_partitions =[];

/**
 * Total available memory
 * 
 *
 * integer
 */
global integer total_memory =0;

/**
 * Number of cpus
 * 
 * integer
 */
integer number_of_cpus = 1;

/** Boolean option indicates kernel parameter
 * "crashkernel"
 *
 * boolean true if kernel parameter is set
 */
global boolean crashkernel_param = false;

/**
 * String option indicates value of kernel parameter
 * "crashkernel"
 *
 * string value of kernel parameter
 */
global string crashkernel_param_value = "";

/**
 * Boolean option indicates add kernel param
 * "crashkernel"
 *
 * boolean true if kernel parameter will be add
 */
global boolean add_crashkernel_param = false;


/**
 * String option for alocate of memory for boot param
 * "crashkernel"
 *
 * string value number of alocate memory
 */
global string alocated_memory = "0";



/**
 * String option identify which boot section was used
 * during boot process
 *
 * string value actual boot section
 */

global string actual_boot_section = "";


/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * map of deafult values for options in UI
 *  
 * global map <string, string >
 */

global map <string, string > DEFAULT_CONFIG = $[
     "KDUMP_KERNELVER"              : "kdump",
     "KDUMP_COMMANDLINE"            : "",
     "KDUMP_COMMANDLINE_APPEND"     : "",  
     "KEXEC_OPTIONS"                : "",  
     "KDUMP_RUNLEVEL"               : "1",
     "KDUMP_IMMEDIATE_REBOOT"       : "yes",
     "KDUMP_TRANSFER"               : "",
     "KDUMP_SAVEDIR"      	    : "file:///var/log/dump",
     "KDUMP_KEEP_OLD_DUMPS"         : "5",
     "KDUMP_FREE_DISK_SIZE"    	    : "64",
     "KDUMP_DUMPDEV"           	    : "",
     "KDUMP_VERBOSE"      	    : "3",
     "KDUMP_DUMPLEVEL"		    : "0",
     "KDUMP_DUMPFORMAT"		    : "ELF", //or "compressed"
];

/**
 * map <string, string > of kdump settings
 *    
 */
global map <string, string > KDUMP_SETTINGS = $[];

/**
 * time for progress bar
 *    
 */
integer sl = 500;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


/**
 * Read disk partitions
 *
 *  @return boolean successfull
 */

boolean ReadDiskPartitions () {
  // get complete map from Storage module
  map<string,map> tg = Storage::GetTargetMap();
  // extract only real disks from target map.
  map<string,map> disks = filter( string k, map disk, tg, ``(disk["type"]:`CT_UNKNOWN==`CT_DISK));    
  // extract only disks
  list <string> list_of_disks = (list<string>) Map::Keys(disks);
  //get a list of all partitions usable for data storage
  list <string> list_disks = (list<string>) Map::Keys(disks);

  y2milestone("[kdump] (ReadDiskPartitions)  ----------------Begin of ReadDiskPartitions ()--------------");
  y2milestone("[kdump] (ReadDiskPartitions) list of disks: %1", list_disks);

  list<map> data_parts = [];
  foreach (string key, list_disks, {
    data_parts = data_parts + filter( map p, disks[key,"partitions"]:[], ``(p["type"]:`primary!=`extended));
  });    
  //list<map> data_parts = filter( map p, disks["/dev/sda","partitions"]:[], ``(p["type"]:`primary!=`extended));

  //parse partiotions with uknown file system
  list<map> unknown = [];
  unknown = filter( map p, data_parts, ``(p["detected_fs"]:nil==`unknown));
 

  list<string> uknown_partitions = [];
  if (size(unknown)>0)
     uknown_partitions = maplist( map p, unknown, ``(p["device"]:""));
  y2milestone("[kdump] (ReadDiskPartitions) list of device names of partitions without filesystem: %1", uknown_partitions);
  uknown_fs_partitions = uknown_partitions;
  // get list of device names of partitions
  list<string> parts = maplist( map p, data_parts, ``(p["device"]:""));
 
  y2milestone("[kdump] (ReadDiskPartitions) list of device names of partitions: %1", parts);

  // get list of udev ids of partitions, need to prepend "/dev/disk/by-id/"
  list<string> udevids = maplist( map p, data_parts, ``(p["udev_id",0]:""));
 
  y2milestone("[kdump] (ReadDiskPartitions) list of udev ids of partitions: %1", udevids);

  
  //combination name + uids to one list
  integer i = 0;
  //available_partitions = parts;
  foreach (string key, udevids, {
    //string disk_from_partition = filterchars(parts[i]:"", "abcdefghijklmnopqrstuvwxyz/");
    string value = "/dev/disk/by-id/" + udevids[i]:"" +" ( " + parts[i]:"" +" )";
    available_partitions = available_partitions + value;
    i= i+1; 
  });
 
  y2milestone("[kdump] (ReadDiskPartitions) list of available partitions (name + uid): %1", available_partitions);
  y2milestone("[kdump] (ReadDiskPartitions)  ------------End of ReadDiskPartitions ()--------------------------");
  return true;
} 


/**
 * Compare boot section options with 
 *
 * options from running kernel
 *  @return integer return number of differences
 */

integer CmpKernelAndBootOptions (list <string> kernel_option, list <string> boot_options) {
  integer result = size(kernel_option);
  integer dif_size = size(boot_options) - size(kernel_option);
  if (dif_size < 0)
     dif_size = dif_size*(-1);
  foreach (string option, kernel_option, {
    if (contains(boot_options, option))
       result = result -1;
  });

  result = result + dif_size;
  return result;
}


/**
 * Function add into option from boot 
 * section root device and vgamode
 * 
 *  @return list <string> boot section + root and vgamode
 */


list <string> AddDeviceVgamode (map section) {
  string tmp_boot_section = tostring(section["append"]:nil);
  //adding root device
  tmp_boot_section = tmp_boot_section + " root=" + tostring(section["root"]:nil);
  tmp_boot_section = tmp_boot_section + " vga=" + tostring(section["vgamode"]:nil);
  
  return splitstring(tmp_boot_section," ");

}


/**
 * Read actual boot section
 *
 * read kernal version and boot options
 *  @return string actual boot section
 */


string GetActualBootSection () {
  //read option from bootlaoder

  string result = "";
  string kernel_boot_options = "";
  string kernel_version = "";
  integer min_dif_size = 1000;
 
  //reading bootloader settings
  boolean old_progress = Progress::set (false);
  Bootloader::Read();
  Progress::set (old_progress);

  //reading kernel options
  string command = "cat /proc/cmdline";
  map options = (map)SCR::Execute (.target.bash_output, command);
  y2milestone("[kdump] (GetActualBootSection) command read boot options from kernel:  %1  output: %2",command, options);  
  
  if (options["exit"]:nil !=  0)
     return "";

  kernel_boot_options = tostring(options["stdout"]:nil);
  //Popup::Message(kernel_boot_options);

  //reading version of kernel
  command = "uname -r";
  options = (map)SCR::Execute (.target.bash_output, command);
  y2milestone("[kdump] (GetActualBootSection) command read kernel version:  %1  output: %2",command, options);  
  
  if (options["exit"]:nil !=  0)
     return "";

  kernel_version = tostring(options["stdout"]:nil);

  //Popup::Message(kernel_version);
  
  y2milestone("[kdump] (GetActualBootSection) kerne version: %1",kernel_version);


  //boot sections from bootloader
  list<map<string,any> > sects = BootCommon::sections;

  //deleting non linux sections
  sects = filter (map<string,any> s, sects, ``(
                ! haskey (s, "chainloader")));
  
  y2milestone("[kdump] (GetActualBootSection) BootCommon::sections only linux sections:  %1",sects);

  //find probably boot section, what was used during start-up
  foreach(map section, sects, {

    string image = tostring(section["image"]:nil);

    if (image != nil) {
       //Popup::Message(image);
       command = "/sbin/get_kernel_version "+image;
       options = (map)SCR::Execute (.target.bash_output, command);

       if (options["exit"]:nil ==  0) {
          string ret = tostring(options["stdout"]:nil);

          if (ret == kernel_version) {
             //Popup::Message("hura!");
             integer value = CmpKernelAndBootOptions(splitstring(kernel_boot_options," "),AddDeviceVgamode(section));
             if (value < min_dif_size) {
                min_dif_size = value;
                result = tostring(section["name"]:nil);		
             }
             //Popup::Message(tostring(value));
          } //end if (ret == kernel_version)
       } // end if (options["exit"]:nil ==  0)     
    } //end of if (image != nil)           
  }); //end of foreach(map section, sects, {

  
  //Popup::Message(result);

  y2milestone("[kdump] (GetActualBootSection) selected boot section :  %1",result);
  return result;

}





/**
 * Read current kdump configuration
 *
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */

boolean ReadKdumpKernelParam () {

  //boolean old_progress = Progress::set (false);
  //Bootloader::Read();
  //Progress::set (old_progress);
  actual_boot_section =  GetActualBootSection ();

  if (actual_boot_section == "")
     actual_boot_section = Bootloader::getDefaultSection ();

  string result = Bootloader::getKernelParam (actual_boot_section, "crashkernel");

  //Popup::Message(result);
  if (result == "false") {
     crashkernel_param = false;
     add_crashkernel_param = false;
  } else { 
     crashkernel_param = true;
     add_crashkernel_param = true;
  }

  crashkernel_param_value = result;
  if (result != "false")
     alocated_memory = substring(result,0,search(result,"M"));

  //Popup::Message(alocated_memory);

  return true;
}

/**
 * Read available cpu
 *
 * 
 *  @return boolean successfull
 */

boolean ReadAvailableCPU () {

  list <map> output =  (list<map>)SCR::Read(.probe.cpu);

  number_of_cpus = size(output);
  y2milestone("[kdump] (ReadAvailableCPU) SCR::Read(.probe.cpu): %1", output);
  y2milestone("[kdump] number of CPUs: %1", number_of_cpus);
  //alocated_memory = "0";
  if (alocated_memory == "0") {     
     if ((number_of_cpus > 16) || ((total_memory/1024) > 16))
        alocated_memory = "256";
     else if ((number_of_cpus > 4) || ((total_memory/1024) > 4))
        alocated_memory = "128";
     else
        alocated_memory = "64";
     y2milestone("[kdump] allocated memory if not set in \"crashkernel\" param: %1", alocated_memory);
  }

  
  return true;
}

/**
 * Read available memory
 *
 * 
 *  @return boolean successfull
 */

boolean ReadAvailableMemory () {

  list <map> output =  (list<map>)SCR::Read(.probe.memory);
  y2milestone("[kdump] (ReadAvailableMemory) SCR::Read(.probe.memory): %1", output);

  map <any,any> resor = $[];
  list <any> temp = maplist(map mem, output,{    
    return mem["resource"]:nil;
  });
  //y2milestone("[kdump] (ReadAvailableMemory) temp: %1", temp);
  resor = tomap(temp[0]:nil);
  
  output = (list<map>)resor["phys_mem"]:nil;
  temp = maplist(map mem, output,{    
    return mem["range"]:nil;
  });
  //list <any> range = maplist(map resor["phys_mem"]:nil);
 
  //resor = (map)range;
  total_memory = tointeger(temp[0]:nil)/1048576;
  y2milestone("[kdump] (ReadAvailableMemory) total phys. memory [MB]: %1", tostring(total_memory));
  ReadAvailableCPU ();
  return true;
}





/**
 * Read current kdump configuration
 *
 *  @return boolean successfull
 */
boolean ReadKdumpSettings () {
    KDUMP_SETTINGS = DEFAULT_CONFIG;
    foreach (string key,  SCR::Dir(.sysconfig.kdump), {
	string val = (string) SCR::Read(add(.sysconfig.kdump, key));
        if (val != nil) KDUMP_SETTINGS[key] = val;
    });

    map <string, string > debug_KDUMP_SETTINGS = KDUMP_SETTINGS;

    debug_KDUMP_SETTINGS["KDUMP_SAVEDIR"] = "";
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("kdump configuration has been read without value \"KDUMP_SAVEDIR\": %1", debug_KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");

    

    return true;
}



/**
 * Write current kdump configuration
 *
 *  @return boolean successfull
 */
boolean WriteKdumpSettings () {
    map <string, string > debug_KDUMP_SETTINGS = KDUMP_SETTINGS;
    debug_KDUMP_SETTINGS["KDUMP_SAVEDIR"] = "";
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("Writing kdump configuration without value \"KDUMP_SAVEDIR\": %1", debug_KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");


    foreach (string option_key, string option_val, KDUMP_SETTINGS, {
	SCR::Write(add(.sysconfig.kdump, option_key), option_val);
    });
    SCR::Write(.sysconfig.kdump, nil);
        
    return true;
}


/**
 * Write kdump boot argument crashkernel
 * set kernel-kdump start at boot
 *
 *  @return boolean successfull
 */
boolean WriteKdumpBootParameter () {
  
  boolean result = true;
  boolean old_progress = false;
  if (add_crashkernel_param) {
     string crash_value = "";
     crash_value = alocated_memory+"M@";
     if ((Arch::i386()) ||(Arch::x86_64())) {
        crash_value = crash_value + "16M";
     } else if (Arch::ia64()) {
        crash_value = crash_value + "0";
     } else if (Arch::ppc64()) {
        crash_value = crash_value + "32M";
     } else {
        if (!Mode::commandline())
           Popup::Error(_("Unsupported architecture, \"crashkernel\" was not added"));
        return false;
     }
           
     if ((!crashkernel_param) || (crash_value != crashkernel_param_value)) {

        //Popup::Message(Bootloader::getDefaultSection ());
        result = Bootloader::setKernelParam (actual_boot_section, "crashkernel", crash_value);
        old_progress = Progress::set (false);
        Bootloader::Write();
        Progress::set (old_progress);
        //Popup::Message(crash_value);
        y2milestone("[kdump] (WriteKdumpBootParameter) adding chrashkernel option with value : %1", crash_value);
        if (!Mode::commandline())
           Popup::Message(_("For applying changes is necessary reboot."));

        Service::Enable("kdump");
        return result;
     }

     
     //start kernel-kdump at boot
     Service::Enable("kdump");

     if (Service::Status("kdump") == 0)
        Service::Restart("kdump");
  } else {
    if (crashkernel_param) {
       //delete crashkernel paramter from bootloader
       result = Bootloader::setKernelParam (actual_boot_section, "crashkernel", "false");
       old_progress = Progress::set (false);
       Bootloader::Write();
       Progress::set (old_progress);
       if (!Mode::commandline())
          Popup::Message(_("For applying changes is necessary reboot."));
    }
    Service::Disable("kdump");
    if (Service::Status("kdump") == 0)
       Service::Stop("kdump");
    return result;
  }    
  return true;
}



/**
 * Read all kdump settings
 * @return true on success
 */
global boolean Read() {

    /* Kdump read dialog caption */
    string caption = _("Initializing kdump Configuration");
    integer steps = 4;
    //sleep(sl);

    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/4 */
	    _("Read the config file"),
	    /* Progress stage 2/4 */
	    _("Read disk partitions"),
            /* Progress stage 3/4 */
            _("Read kernel boot options"),
            /* Progress stage 4/4 */
            _("Read available memory"),
 
	], [
	    /* Progress step 1/4 */
	    _("Reading the config file..."),
            /* Progress step 2/4*/
            _("Reading partitions of disks..."),
            /* Progress finished 3/4*/ 
            _("Reading available memory..."),
	    /* Progress finished 4/4*/
	    Message::Finished()
	],
	""
    );

    //sleep(sl);
    // read database
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!ReadKdumpSettings ()) Report::Error(_("Cannot read config file /etc/sysconfig/kdump"));
    //sleep(sl);

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadDiskPartitions ()) Report::Error(_("Cannot read disk partitions."));
    //sleep(sl);

   // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadKdumpKernelParam ()) Report::Error(_("Cannot read kernel boot options"));
    //sleep(sl);

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadAvailableMemory ()) Report::Error(_("Cannot read available memory"));
    //sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    //sleep(sl);

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all kdump settings
 * @return true on success
 */
global boolean Write() {

    /* Kdump read dialog caption */
    string caption = _("Saving kdump Configuration");

    //number of stages
    integer steps = 2;

    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Update boot options")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Updating boot options..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!WriteKdumpSettings ()) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // write/delete bootloader option for kernel "crashkernel"
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(!WriteKdumpBootParameter ()) Report::Error (_("Adding crashkernel parameter to bootloader fault."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();
    sleep(sl);

    if(Abort()) return false;
    return true;
}

/* EOF */
}
