/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Kdump.ycp
 * Package:	Configuration of kdump
 * Summary:	Kdump settings, input and output functions
 * Authors:	Jozef Uhliarik <juhliarik@suse.com>
 *
 * $Id: Kdump.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of kdump.
 * Input and output routines.
 */

{

module "Kdump";
textdomain "kdump";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "BootCommon";
import "Storage";
import "Map";
import "Bootloader";
import "Service";
import "Popup";
import "Arch";
import "Mode";
import "BootCommon";
import "Map";
import "ProductControl";
import "ProductFeatures";

/**
 * Prototypes
 */
global boolean GetModified();

global void SetModified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * List of available partiotions
 * with known partition
 *
 * list <string>
 */
global list <string> available_partitions =[];

/**
 * true if propose was called
 */
global boolean propose_called = false;

/**
 * List of available partiotions
 * without filesystem or with uknown
 *
 * list <string>
 */
global list <string> uknown_fs_partitions =[];

/**
 * Total available memory [MB]
 * 
 *
 * integer
 */
global integer total_memory =0;

/** Boolean option indicates that "crashkernel" includes
 *  several ranges
 *
 * boolean true if there are several ranges (>1)
 */
global boolean crashkernel_list_ranges = false;


/** 
 *  list of packages for installation
 */
global list<string> kdump_packages =[];

/**
 * Number of cpus
 * 
 * integer
 */
integer number_of_cpus = 1;

/**
 * kernel version (uname -r)
 * 
 * string
 */
string kernel_version = "";


/**
 * Position actual boot section in BootCommon::sections list
 * it is relevant only if XEN boot section is used
 *
 * integer
 */
integer section_pos = -1;


/** Boolean option indicates kernel parameter
 * "crashkernel"
 *
 * boolean true if kernel parameter is set
 */
global boolean crashkernel_param = false;

/**
 * String option indicates value of kernel parameter
 * "crashkernel"
 *
 * string value of kernel parameter
 */
global string crashkernel_param_value = "";

/**
 * Boolean option indicates add kernel param
 * "crashkernel"
 *
 * boolean true if kernel parameter will be add
 */
global boolean add_crashkernel_param = false;


/**
 * String option for alocate of memory for boot param
 * "crashkernel"
 *
 * string value number of alocate memory
 */
global string alocated_memory = "0";



/**
 * String option identify which boot section was used
 * during boot process
 *
 * string value actual boot section
 */

global string actual_boot_section = "";


/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = nil;

/**
 * map of deafult values for options in UI
 *  
 * global map <string, string >
 */

global map <string, string > DEFAULT_CONFIG = $[
     "KDUMP_KERNELVER"              : "kdump",
     "KDUMP_COMMANDLINE"            : "",
     "KDUMP_COMMANDLINE_APPEND"     : "",  
     "KEXEC_OPTIONS"                : "",  
     "KDUMP_RUNLEVEL"               : "1",
     "KDUMP_IMMEDIATE_REBOOT"       : "yes",
     "KDUMP_TRANSFER"               : "",
     "KDUMP_SAVEDIR"      	    : "file:///var/log/dump",
     "KDUMP_KEEP_OLD_DUMPS"         : "5",
     "KDUMP_FREE_DISK_SIZE"    	    : "64",
     "KDUMP_DUMPDEV"           	    : "",
     "KDUMP_VERBOSE"      	    : "3",
     "KDUMP_DUMPLEVEL"		    : "0",
     "KDUMP_DUMPFORMAT"		    : "ELF", //or "compressed"
];

/**
 * map <string, string > of kdump settings
 *    
 */
global map <string, string > KDUMP_SETTINGS = $[];

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean GetModified() {
    y2debug("modified=%1",modified);
    return modified;
}


/**
 * Set data was modified
 */
global void SetModified() {
    modified = true;
    y2debug("modified=%1",modified);
}

/**
 * Read disk partitions
 *
 *  @return boolean successfull
 */

boolean ReadDiskPartitions () {
  // get complete map from Storage module
  map<string,map> tg = Storage::GetTargetMap();
  // extract only real disks from target map.
  map<string,map> disks = filter( string k, map disk, tg, ``(disk["type"]:`CT_UNKNOWN==`CT_DISK));    
  // extract only disks
  list <string> list_of_disks = (list<string>) Map::Keys(disks);
  // get a list of all partitions usable for data storage
  list <string> list_disks = (list<string>) Map::Keys(disks);

  y2milestone("[kdump] (ReadDiskPartitions)  ----------------Begin of ReadDiskPartitions ()--------------");
  y2milestone("[kdump] (ReadDiskPartitions) list of disks: %1", list_disks);

  list<map> data_parts = [];
  foreach (string key, list_disks, {
    data_parts = data_parts + filter( map p, disks[key,"partitions"]:[], ``(p["type"]:`primary!=`extended));
  });    
  //list<map> data_parts = filter( map p, disks["/dev/sda","partitions"]:[], ``(p["type"]:`primary!=`extended));

  // parse partiotions with uknown file system
  list<map> unknown = [];
  unknown = filter( map p, data_parts, ``(p["detected_fs"]:nil==`unknown));
 

  list<string> uknown_partitions = [];
  if (size(unknown)>0)
     uknown_partitions = maplist( map p, unknown, ``(p["device"]:""));
  y2milestone("[kdump] (ReadDiskPartitions) list of device names of partitions without filesystem: %1", uknown_partitions);
  uknown_fs_partitions = uknown_partitions;
  // get list of device names of partitions
  list<string> parts = maplist( map p, data_parts, ``(p["device"]:""));
 
  y2milestone("[kdump] (ReadDiskPartitions) list of device names of partitions: %1", parts);

  // get list of udev ids of partitions, need to prepend "/dev/disk/by-id/"
  list<string> udevids = maplist( map p, data_parts, ``(p["udev_id",0]:""));
 
  y2milestone("[kdump] (ReadDiskPartitions) list of udev ids of partitions: %1", udevids);

  
  // combination name + uids to one list
  integer i = 0;
  // available_partitions = parts;
  foreach (string key, udevids, {
    // string disk_from_partition = filterchars(parts[i]:"", "abcdefghijklmnopqrstuvwxyz/");
    string value = "/dev/disk/by-id/" + udevids[i]:"" +" ( " + parts[i]:"" +" )";
    available_partitions = available_partitions + value;
    i= i+1; 
  });
 
  y2milestone("[kdump] (ReadDiskPartitions) list of available partitions (name + uid): %1", available_partitions);
  y2milestone("[kdump] (ReadDiskPartitions)  ------------End of ReadDiskPartitions ()--------------------------");
  return true;
} 


/**
 * Compare boot section options with 
 *
 * options from running kernel
 *  @return integer return number of differences
 */

integer CmpKernelAndBootOptions (list <string> kernel_option, list <string> boot_options) {
  integer result = size(kernel_option);
  integer dif_size = size(boot_options) - size(kernel_option);
  if (dif_size < 0)
     dif_size = dif_size*(-1);
  foreach (string option, kernel_option, {
    if (contains(boot_options, option))
       result = result -1;
  });

  result = result + dif_size;
  return result;
}


/**
 * Function add into option from boot 
 * section root device and vgamode
 * 
 *  @return list <string> boot section + root and vgamode
 */


list <string> AddDeviceVgamode (map section) {
  string tmp_boot_section = tostring(section["append"]:nil);
  // adding root device
  tmp_boot_section = tmp_boot_section + " root=" + tostring(section["root"]:nil);
  tmp_boot_section = tmp_boot_section + " vga=" + tostring(section["vgamode"]:nil);
  
  return splitstring(tmp_boot_section," ");

}


/**
 * Read actual boot section
 *
 * read kernal version and boot options
 *  @return string actual boot section
 */


string GetActualBootSection () {
  // read option from bootlaoder

  string result = "";
  string kernel_boot_options = "";
  integer min_dif_size = 1000;
 
  // reading bootloader settings
  boolean old_progress = Progress::set (false);
  Bootloader::Read();
  Progress::set (old_progress);

  // reading kernel options
  string command = "cat /proc/cmdline";
  map options = (map)SCR::Execute (.target.bash_output, command);
  y2milestone("[kdump] (GetActualBootSection) command read boot options from kernel:  %1  output: %2",command, options);  
  
  if (options["exit"]:nil !=  0)
     return "";

  kernel_boot_options = tostring(options["stdout"]:nil);

  // reading version of kernel
  command = "uname -r";
  options = (map)SCR::Execute (.target.bash_output, command);
  y2milestone("[kdump] (GetActualBootSection) command read kernel version:  %1  output: %2",command, options);  
  
  if (options["exit"]:nil !=  0)
     return "";

  kernel_version = tostring(options["stdout"]:nil);  
  y2milestone("[kdump] (GetActualBootSection) kerne version: %1",kernel_version);

  // boot sections from bootloader
  list<map<string,any> > sects = BootCommon::sections;

  // deleting non linux sections
  sects = filter (map<string,any> s, sects, ``(
                ! haskey (s, "chainloader")));
  
  y2milestone("[kdump] (GetActualBootSection) BootCommon::sections only linux sections:  %1",sects);

  // find probably boot section, what was used during start-up
  foreach(map section, sects, {

    string image = tostring(section["image"]:nil);

    if (image != nil) {
       command = "/sbin/get_kernel_version "+image;
       options = (map)SCR::Execute (.target.bash_output, command);

       if (options["exit"]:nil ==  0) {
          string ret = tostring(options["stdout"]:nil);

          if (ret == kernel_version) {
             //Popup::Message("hura!");
             integer value = CmpKernelAndBootOptions(splitstring(kernel_boot_options," "),AddDeviceVgamode(section));
             if (value < min_dif_size) {
                min_dif_size = value;
                result = tostring(section["name"]:nil);		
             }
          } // end if (ret == kernel_version)
       } // end if (options["exit"]:nil ==  0)     
    } // end of if (image != nil)           
  }); // end of foreach(map section, sects, {

  y2milestone("[kdump] (GetActualBootSection) selected boot section :  %1",result);
  return result;

}

/**
 * get value of crashkernel option
 * from XEN boot section
 *  @param string crashkernel=64M@16M
 *  @return string value of carshkernel option
 */

string getCrashKernelValue (string crash)
{
    y2milestone("crashkernel option %1", crash);
    string result ="";
    if ((crash != "") || (crash != nil))
    {
	integer position = search(crash, "=");
	if (position != nil)
	    result = substring(crash, position+1); 
	else
	    y2error("Wrong crashkernel option!");

    }
    y2milestone("crashkernel value is %1", result);
    return result;

}

/**
 * get alocated memory from value of crashkernel option
 * there can be several ranges -> take the first range
 *  @param string 64M@16M or 128M-:64M@16M [(reserved_memory*2)-:reserved_memory]
 *  @return string value of alocated memory (64M)
 */

string getAlocatedMemory(string crash_value)
{
   string result = "";
   string allocated = "";
   string range ="";
   if (search(crash_value,",") != nil)
   {
      list<string> ranges = splitstring(crash_value,",");
      crashkernel_list_ranges = true;
      range = ranges[0]:"";

   } else {
      range = crash_value;
   }
   y2milestone("The 1st range from crashkernel is %1", result);
   integer position =  search(range,":");
 
   if (position != nil) 
      allocated = substring(range, position+1);
   else
      allocated = range;

   result = substring(allocated,0,search(allocated,"M"));

   y2milestone("Allocated memory is %1", result);
   return result;
}

/**
 * Build crashkernel value from alocated memory
 * 
 *  @return string value of crashkernel
 */

string BuildCrashkernelValue ()
{
    // if user doesn't modified or select don't modify 
    // return readed value
    if (crashkernel_list_ranges)
	return crashkernel_param_value;

    string crash_value = "";
    crash_value = alocated_memory+"M";
    if ((Arch::i386()) ||(Arch::x86_64()) || Arch::ppc64()) {
        crash_value = crash_value + "@16M";
	y2milestone("Common offset 16M");
    } else if (Arch::ia64()) {
        y2milestone("ia64 platform without offset");
    } else {
       if (!Mode::commandline())
          Popup::Error(_("Unsupported architecture, \"crashkernel\" was not added"));
       y2error("Unsupported platform/architecture...");
    }

    string reserved_memory = tostring(2*tointeger(alocated_memory));
    

    crash_value = reserved_memory+"M-:"+crash_value;
    y2milestone("builded crashkernel value is %1", crash_value);
    return crash_value;

}


/**
 * Check if default boot section is Xen section
 * remember position of section (important for saving to xen_append)
 * @param string name of section
 */

define void CheckXenDefault(string act_boot_secion)
{
    if ((act_boot_secion != "") && (act_boot_secion != nil))
    {
       integer section_position = -1;
       foreach(map section, BootCommon::sections, 
       {
	    section_position = section_position +1;
            string name = tostring(section["name"]:nil);
	    string type = tostring(section["type"]:nil);

            if ((name == act_boot_secion) && (type == "xen"))
            { 
	       section_pos = section_position;
               y2milestone("default boot section is Xen...");
            }              

       });
       if (section_pos == -1)
          y2milestone("default boot section is NOT Xen...");
    }
}

/**
 * Read current kdump configuration
 * from XEN boot section
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */


boolean ReadXenKdumpKernelParam (string act_boot_secion)
{

    string crash = "";
    if (actual_boot_section == "")
    {
	y2milestone("Actual boot section was not found");
	crashkernel_param = false;
        add_crashkernel_param = false;
    } else {
	integer section_position = -1;
        foreach(map section, BootCommon::sections, 
        {
	    section_position = section_position +1;
            string name = tostring(section["name"]:nil);

            if (name == act_boot_secion) 
            {
		crash = section["xen_append"]:"";
		section_pos = section_position;
	    }              
        });
    }

    if (crash != "")
    {
	list<string> xen_append = splitstring(crash, " ");
	string crash_arg = "";

	if (size(xen_append)>1)
	{
	   foreach(string key, xen_append,
	   {
		if (search(key, "crashkernel") != nil)
		   crash_arg = key;
           });
        } else {
	   crash_arg = crash;
	}

	if (crash_arg != "")
	{
	   crashkernel_param = true;
     	   add_crashkernel_param = true;
	   crashkernel_param_value =  getCrashKernelValue(crash_arg);
           alocated_memory = getAlocatedMemory(crashkernel_param_value);
	} else {
 	   crashkernel_param = false;
           add_crashkernel_param = false;
	}
    }

    return true;
}


/**
 * Read current kdump configuration
 *
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */

boolean ReadKdumpKernelParam () {
 
  actual_boot_section =  GetActualBootSection ();

  if (search(kernel_version, "xen") != nil)
      return ReadXenKdumpKernelParam (actual_boot_section);


  if (actual_boot_section == "")
     actual_boot_section = Bootloader::getDefaultSection ();

  string result = Bootloader::getKernelParam (actual_boot_section, "crashkernel");

  //Popup::Message(result);
  if (result == "false") {
     crashkernel_param = false;
     add_crashkernel_param = false;
  } else { 
     crashkernel_param = true;
     add_crashkernel_param = true;
  }

  crashkernel_param_value = result;
  if (result != "false")
     alocated_memory = getAlocatedMemory(crashkernel_param_value);

  return true;
}

/**
 * Propose reserved/allocated memory
 *
 * 
 *  @return boolean successfull
 */

boolean ProposeAlocatedMemory () 
{
  if (alocated_memory == "0") 
  {     
     if ((total_memory > 512) &&  (total_memory/1024) <2)
        alocated_memory = "64";
     else if ((total_memory/1024) > 2)
        alocated_memory = "128";     
  }
  y2milestone("[kdump] allocated memory if not set in \"crashkernel\" param: %1", alocated_memory);
  return true;
}

/**
 * Read available memory
 *
 * 
 *  @return boolean successfull
 */

boolean ReadAvailableMemory () {

  list <map> output =  (list<map>)SCR::Read(.probe.memory);
  y2milestone("[kdump] (ReadAvailableMemory) SCR::Read(.probe.memory): %1", output);

  map <any,any> resor = $[];
  list <any> temp = maplist(map mem, output,{    
    return mem["resource"]:nil;
  });
  //y2milestone("[kdump] (ReadAvailableMemory) temp: %1", temp);
  resor = tomap(temp[0]:nil);
  
  output = (list<map>)resor["phys_mem"]:nil;
  temp = maplist(map mem, output,{    
    return mem["range"]:nil;
  });
  //list <any> range = maplist(map resor["phys_mem"]:nil);
 
  //resor = (map)range;
  total_memory = tointeger(temp[0]:nil)/1048576;
  y2milestone("[kdump] (ReadAvailableMemory) total phys. memory [MB]: %1", tostring(total_memory));
  ProposeAlocatedMemory ();
  return true;
}



/**
 * Read current kdump configuration
 *
 *  @return boolean successfull
 */
boolean ReadKdumpSettings () {
    KDUMP_SETTINGS = DEFAULT_CONFIG;
    foreach (string key,  SCR::Dir(.sysconfig.kdump), {
	string val = (string) SCR::Read(add(.sysconfig.kdump, key));
        if (val != nil) KDUMP_SETTINGS[key] = val;
    });

    map <string, string > debug_KDUMP_SETTINGS = KDUMP_SETTINGS;

    // delete KDUMP_SAVEDIR - it can include password
    debug_KDUMP_SETTINGS["KDUMP_SAVEDIR"] = "";
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("kdump configuration has been read without value \"KDUMP_SAVEDIR\": %1", debug_KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");

    return true;
}



/**
 * Write current kdump configuration
 *
 *  @return boolean successfull
 */
boolean WriteKdumpSettings () {
    map <string, string > debug_KDUMP_SETTINGS = KDUMP_SETTINGS;
    // delete KDUMP_SAVEDIR - it can include password
    debug_KDUMP_SETTINGS["KDUMP_SAVEDIR"] = "";
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("Writing kdump configuration without value \"KDUMP_SAVEDIR\": %1", debug_KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");

    foreach (string option_key, string option_val, KDUMP_SETTINGS, {
	SCR::Write(add(.sysconfig.kdump, option_key), option_val);
    });
    SCR::Write(.sysconfig.kdump, nil);
        
    return true;
}


/**
 * Write kdump boot argument crashkernel
 * set kernel-kdump start at boot
 *
 *  @return boolean successfull
 */
boolean WriteKdumpBootParameter () {
  boolean result = true;
  boolean old_progress = false;
  if (Mode::installation())
  {
     Bootloader::Read();
     actual_boot_section = Bootloader::getDefaultSection ();
     y2milestone("Default boot section is %1", actual_boot_section);
     CheckXenDefault(actual_boot_section);
  }
  if (add_crashkernel_param) {
     string crash_value = BuildCrashkernelValue ();
           
     if ((!crashkernel_param) || (crash_value != crashkernel_param_value)) {

        // write crashkernel option to boot section
	if (section_pos == -1)
	{
            result = Bootloader::setKernelParam (actual_boot_section, "crashkernel", crash_value);
	} else {
	    
	    BootCommon::sections[section_pos, "xen_append"]= "crashkernel="+crash_value;
	    result = true;
	    y2milestone("Write boot section to XEN boot section %1", BootCommon::sections[section_pos]:nil);
	}
        old_progress = Progress::set (false);
        Bootloader::Write();
        Progress::set (old_progress);
        // Popup::Message(crash_value);
        y2milestone("[kdump] (WriteKdumpBootParameter) adding chrashkernel option with value : %1", crash_value);
        if (Mode::normal())
           Popup::Message(_("To apply changes a reboot is necessary."));

        Service::Enable("kdump");
        return result;
     }
     
     // start kernel-kdump at boot
     Service::Enable("kdump");

     if (Service::Status("kdump") == 0)
        Service::Restart("kdump");
  } else {
    if (crashkernel_param) {
       //delete crashkernel paramter from bootloader
       result = Bootloader::setKernelParam (actual_boot_section, "crashkernel", "false");
       old_progress = Progress::set (false);
       Bootloader::Write();
       Progress::set (old_progress);
       if (Mode::normal())
          Popup::Message(_("To apply changes a reboot is necessary."));
    }
    Service::Disable("kdump");
    if (Service::Status("kdump") == 0)
       Service::Stop("kdump");
    return result;
  }    
  return true;
}



/**
 * Read all kdump settings
 * @return true on success
 */
global boolean Read() 
{
    /* Kdump read dialog caption */
    string caption = _("Initializing kdump Configuration");
    integer steps = 4;

    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/4 */
	    _("Reading the config file..."),
	    /* Progress stage 2/4 */
	    _("Reading disk partitions..."),
            /* Progress stage 3/4 */
            _("Reading kernel boot options..."),
            /* Progress stage 4/4 */
            _("Reading available memory..."),
 
	], [
	    /* Progress step 1/4 */
	    _("Reading the config file..."),
            /* Progress step 2/4*/
            _("Reading partitions of disks..."),
            /* Progress finished 3/4*/ 
            _("Reading available memory..."),
	    /* Progress finished 4/4*/
	    Message::Finished()
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!ReadKdumpSettings ()) Report::Error(_("Cannot read config file /etc/sysconfig/kdump"));

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadDiskPartitions ()) Report::Error(_("Cannot read disk partitions."));

   // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadKdumpKernelParam ()) Report::Error(_("Cannot read kernel boot options."));

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadAvailableMemory ()) Report::Error(_("Cannot read available memory."));

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Write all kdump settings
 * @return true on success
 */
global boolean Write() 
{
    /* Kdump read dialog caption */
    string caption = _("Saving kdump Configuration");

    //number of stages
    integer steps = 2;
    if (Mode::installation())
    {
       boolean write_kdump = ProductFeatures::GetBooleanFeature ("globals", "enable_kdump");
       if ((write_kdump == nil) || (!write_kdump))
       {
	  y2milestone("Installation doesn't support kdump.");
          return true;
       }
    }
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Update boot options")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Updating boot options..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!WriteKdumpSettings ()) Report::Error (_("Cannot write settings."));

    // write/delete bootloader option for kernel "crashkernel"
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(!WriteKdumpBootParameter ()) Report::Error (_("Adding crashkernel parameter to bootloader fault."));

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    return true;
}

/**
 * Adding necessary packages for installation
 *
 */

define void AddPackages()
{
    
    if (Mode::installation()) 
    {
        kdump_packages = add(kdump_packages, "kexec-tools");
	kdump_packages = add(kdump_packages, "yast2-kdump");
        if (Arch::ppc64())
            kdump_packages = add(kdump_packages, "kernel-kdump");
        else
            kdump_packages = add(kdump_packages, "kdump");          	
    }
}

/**
 * Propose global variables once...
 * after that remember user settings
 */

define void ProposeGlobalVars()
{
    if (!propose_called)
    {
       // set adding boot option...
       crashkernel_param = false;
       add_crashkernel_param = true;
       // added defualt settings
       KDUMP_SETTINGS = DEFAULT_CONFIG;     
    }
    propose_called = true;
}


/**
 * Check if user enabled kdump
 * if no deselect packages for installing
 * if yes add necessary packages for installation
 */
global define void CheckPackages()
{
    // remove duplicates
    kdump_packages = toset(kdump_packages);
    if (!add_crashkernel_param)
    {
	y2milestone("deselect packages for installation: %1", kdump_packages);
        boolean pkg_deselect = false;
        foreach (string p, kdump_packages, 
	{
	    if (Pkg::IsSelected (p))
	    {
		Pkg::PkgNeutral (p);
		pkg_deselect = true;
	    }
	});
	if (pkg_deselect)
	{
	    // if package was added in inst. proposal, I can't be sure
	    // that dependencies will be solved
	    Pkg::PkgSolve (false);
	}
    } else {
	y2milestone("select packages for installation: %1", kdump_packages);
	boolean pkg_added = false;
	foreach (string p, kdump_packages, 
	{
	    if (!Pkg::IsSelected (p))
	    {
		Pkg::PkgInstall (p);
		pkg_added = true;
	    }
	});
	if (pkg_added)
	{
	    // if package was added in inst. proposal, I can't be sure
	    // that dependencies will be solved
	    Pkg::PkgSolve (false);
	}
    }
}

/**
 * Propose all kdump settings
 *
 */
global define void Propose () 
{

    y2milestone("Proposing new settings of kdump");

    // set available partitions...
    ReadDiskPartitions ();

    // set default values for global variables
    ProposeGlobalVars();
    // read available memory
    ReadAvailableMemory ();

    // add packages for installation
    AddPackages();

    // select packages for installation
    CheckPackages();

}
/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list<string> Summary () 
{
    list<string> result = [];
    result = add (result, sformat (_("Kdump status: %1"), (add_crashkernel_param ? _("enabled") :_("disabled"))));
    if (add_crashkernel_param )
    {
    	result = add (result, sformat (_("Value of crashkernel option: %1"), BuildCrashkernelValue()));
    	result = add (result, sformat (_("Dump format: %1"), KDUMP_SETTINGS["KDUMP_DUMPFORMAT"]:""));
    	result = add (result, sformat (_("Target of dumps: %1"), KDUMP_SETTINGS["KDUMP_SAVEDIR"]:""));
    	result = add (result, sformat (_("Number of dumps: %1"), KDUMP_SETTINGS["KDUMP_KEEP_OLD_DUMPS"]:""));
    }
    return result;
}

/**
 * Export kdump settings to a map
 * @return kdump settings
 */
global define map Export () 
{
    map out = $[
	    "crash_kernel" : BuildCrashkernelValue(),
	    "add_crash_kernel" :  add_crashkernel_param,
	    "general" : KDUMP_SETTINGS,
    ];

    y2milestone ("Kdump exporting settings: %1", out);
    return out;

}

/**
 * Import settings from a map
 * @param settings map of kdump settings
 * @return boolean true on success
 */
global define boolean Import (map settings) 
{
    crashkernel_param_value = settings["crash_kernel"]:"";
    add_crashkernel_param = settings["add_crash_kernel"]:false;
    boolean result = true;
    map <string, string > my_import_map = settings["general"]:$[];
    foreach (any key, Map::Keys(DEFAULT_CONFIG), 
    {
	string str_key = tostring(key);
    	string val = (string) my_import_map[str_key]:nil;	
    	if (val != nil) KDUMP_SETTINGS[str_key] = val;
    	if (val == nil) KDUMP_SETTINGS[str_key] = DEFAULT_CONFIG[str_key]:nil; 
    });        
    return result;
}
/* EOF */
}
